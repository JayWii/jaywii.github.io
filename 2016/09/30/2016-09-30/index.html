<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Jaywii"><meta name="description" content="为什么要使用模块模式？因为在全局作用域中声明的变量和函数都自动成为全局对象Window的属性，这经常会导致命名冲突，还会导致一些非常重要的可维护性难题，全局变量越多，引入错误BUG的概率就越大！所以我们应当尽可能少地使用全局变量，模块化的目的之一就是为了解决该问题的！"><meta name="keywords" content="JS,模块化"><title>模块化JS代码 · Jaywii</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://yoursite.com/2016/09/30/2016-09-30/"><link rel="alternate" href="/atom.xml" title="Jaywii"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><div class="headerCont"><a href="/." class="logo">Jaywii</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">首页</a></li><li class="nav-link"><a href="/archives/" target="_self">文章</a></li><li class="nav-link"><a href="/categories/" target="_self">分类</a></li><li class="nav-link"><a href="/tags/" target="_self">标签</a></li><li class="nav-link"><a href="/about/" target="_self">关于</a></li></ul></div></header><section id="container"><article class="post"><h1 class="post-title">模块化JS代码</h1><span class="post-time">Sep 30, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要使用模块模式？"><span class="toc-text">为什么要使用模块模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#零全局变量模式"><span class="toc-text">零全局变量模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单全局变量模式"><span class="toc-text">单全局变量模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个模块的定义"><span class="toc-text">一个模块的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#现代的模块机制"><span class="toc-text">现代的模块机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步模块定义（AMD）"><span class="toc-text">异步模块定义（AMD）:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未来的模块机制"><span class="toc-text">未来的模块机制</span></a></li></ol></div><div class="post-content"><h2 id="为什么要使用模块模式？"><a href="#为什么要使用模块模式？" class="headerlink" title="为什么要使用模块模式？"></a>为什么要使用模块模式？</h2><p>因为在全局作用域中声明的变量和函数都自动成为全局对象Window的属性，这经常会导致命名冲突，还会导致一些非常重要的可维护性难题，全局变量越多，引入错误BUG的概率就越大！所以我们应当尽可能少地使用全局变量，模块化的目的之一就是为了解决该问题的！<br><a id="more"></a></p>
<h2 id="零全局变量模式"><a href="#零全局变量模式" class="headerlink" title="零全局变量模式"></a>零全局变量模式</h2><p>该模式应用场景较少，通过一个IIFE(立即执行的匿名函数)，将所有代码包装起来，这样一来所有的变量、函数都被隐藏在该函数内部，不会污染全局。</p>
<p>使用情景：</p>
<ol>
<li>当该代码不会被其它代码所依赖时；</li>
<li>当不需要在运行时不断的扩展或修改该代码时；</li>
<li>当代码较短，且无需和其它代码产生交互时；</li>
</ol>
<h2 id="单全局变量模式"><a href="#单全局变量模式" class="headerlink" title="单全局变量模式"></a>单全局变量模式</h2><p><strong>基本定义</strong></p>
<p>单全局变量模式即只创建一个全局变量（或尽可能少地创建全局变量），且该全局变量的名称必须是独一无二的，不会和现在、将来的内置API产生冲突，将所有的功能代码都挂载到这个全局变量上。</p>
<p>它已经被广泛应用于各种流行的类库中，如：</p>
<ol>
<li>YUI定义了唯一的YUI全局对象</li>
<li>JQuery定义了两个全局对象，$和JQuery</li>
<li>Dojo定义了一个dojo全局对象</li>
<li>Closure定义了一个goog全局对象<br>例子：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Mymodule= &#123;&#125;;</div><div class="line"></div><div class="line">Mymodule.Book = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;;</div><div class="line">Mymodule.Book.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;....&#125;;</div><div class="line"></div><div class="line">Mymodule.Car = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;;</div><div class="line">Mymodule.Car.prototype.getWheels = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;....&#125;;</div></pre></td></tr></table></figure>
<h2 id="一个模块的定义"><a href="#一个模块的定义" class="headerlink" title="一个模块的定义"></a>一个模块的定义</h2><p>模块是一种通用的功能片段，它并没有创建新的全局变量或命名空间，相反，所有的代码都存放于一个单函数中，可以用一个名称来表示这个模块，同样这个模块可以依赖其他模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> something = <span class="string">'cool'</span>;</div><div class="line">        <span class="keyword">var</span> another = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log( something);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(another.join(<span class="string">'!'</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">doSomething</span>: doSomething,</div><div class="line">            <span class="attr">doAnother</span>: doAnother</div><div class="line">        &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = CoolModule();</div><div class="line">foo.doSomething(); <span class="comment">//cool</span></div><div class="line">foo.doAnother(); <span class="comment">//1!2!3</span></div></pre></td></tr></table></figure></p>
<p>这里的CoolModule 就是一个模块，不过它只是一个函数，这里调用CoolModule函数来创建一个模块的实例foo，此时就形成了闭包（因为CoolModule返回一个对象，其中的一个属性引用了内部函数），模块CoolModule返回的对象就是该模块的公共API（也可以直接返回一个内部函数）</p>
<p>所以，模块模式需要具备两个必要条件：</p>
<ol>
<li>必须有外部的封闭函数，且该函数必须至少被调用一次（每次调用都会创建一个新的模块实例），如CoolModule</li>
<li>封闭函数必须至少有一个内部函数被返回，这样内部函数才能在私有作用域中形成闭包，并且可以访问或修改私有的状态<br>单例模块模式的实现：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = ( <span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        ...<span class="comment">//代码同上例</span></div><div class="line">&#125;)();</div><div class="line">foo.doSomething();</div><div class="line">foo.doAnother();</div></pre></td></tr></table></figure>
<p>还可以通过在模块内部保留对公共API对象的内部引用，这样就可以在内部对模块实例进行修改，包括添加、删除方法和属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> something = <span class="string">'cool'</span>;</div><div class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        pubicAPI.doSomething = doAnother;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( something);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">'!'</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> pubicAPI = &#123;</div><div class="line">        <span class="attr">change</span>: change,</div><div class="line">        <span class="attr">doSomething</span>: doSomething</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> pubicAPI;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = CoolModule();</div><div class="line">foo.doSomething(); <span class="comment">//cool</span></div><div class="line">foo.change();</div><div class="line">foo.doSomething(); <span class="comment">//1!2!3</span></div><div class="line"><span class="keyword">var</span> foo1 = CoolModule();</div><div class="line">foo1.doSomething(); <span class="comment">//cool</span></div></pre></td></tr></table></figure>
<h2 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h2><p>命名空间是简单的通过在全局变量中添加属性来表示的功能性分组。<br>将不同功能按照命名空间进行分组，可以让你的单全局变量变得井然有序，同时可以让团队成员能够知晓新功能应该在哪个部分中定义，或者去哪个部分查找已有功能。<br>例如：定义一个全局变量Y，Y.DOM下的所有方法都是和操作DOM相关的，Y.Event下的所有方法都是和事件相关的。</p>
<ol>
<li>常见的用法是为每一个单独的JS文件创建一个新的全局变量来声明自己的命名空间；</li>
<li>每个文件都需要给一个命名空间挂载功能；这时就需要首先保证该命名空间是已经存在的，可以在单全局变量中定义一个方法来处理该任务：该方法在创建新的命名空间时不会对已有的命名空间造成破坏，使用命名空间时也不需要再去判断它是否存在。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyGolbal = &#123;</div><div class="line">    <span class="attr">namespace</span>: <span class="function"><span class="keyword">function</span> (<span class="params">ns</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> parts = ns.split(<span class="string">'.'</span>),</div><div class="line">            obj = <span class="keyword">this</span>,</div><div class="line">            i, len = parts.length;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(!obj[parts[i]])&#123;</div><div class="line">                obj[parts[i]] = &#123;&#125;</div><div class="line">            &#125;</div><div class="line">            obj = obj[parts[i]];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">MyGolbal.namespace(<span class="string">'Book'</span>); <span class="comment">//创建Book</span></div><div class="line">MyGolbal.Book; <span class="comment">//读取</span></div><div class="line">MyGolbal.namespace(<span class="string">'Car'</span>).prototype.getWheel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p>大多数模块依赖加载器或管理器，本质上都是将这种模块定义封装进一个友好的API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++)&#123;</div><div class="line">            deps[i] = modules[deps[i]];</div><div class="line">        &#125;</div><div class="line">        modules[name] = impl.apply(impl,deps);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> modules[name];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">define</span>: define,</div><div class="line">        <span class="attr">get</span>: get</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>以上代码的核心是<code>modules[name] = impl.apply(impl,deps);</code>，为了模块的定义引入了包装函数(可以传入任何依赖)，并且将模块的API存储在一个根据名字来管理的模块列表modules对象中；<br>使用模块管理器MyModules来管理模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">MyModules.define(<span class="string">'bar'</span>,[],<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'let me introduce: '</span>+who;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">        <span class="attr">hello</span>: hello</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line">MyModules.define(<span class="string">'foo'</span>,[<span class="string">'bar'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">bar</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hungry = <span class="string">'hippo'</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">awesome</span>: awesome</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> foo = MyModules.get(<span class="string">'foo'</span>);</div><div class="line">foo.awesome();<span class="comment">//LET ME INTRODUCE: HIPPO</span></div></pre></td></tr></table></figure>
<h2 id="异步模块定义（AMD）"><a href="#异步模块定义（AMD）" class="headerlink" title="异步模块定义（AMD）:"></a>异步模块定义（AMD）:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'my-books'</span>, [<span class="string">'dependency1'</span>,<span class="string">'dependency2'</span>], </div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">dependency1, dependency2</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> Books = &#123;&#125;;</div><div class="line">        Books.author = &#123;<span class="attr">author</span>: <span class="string">'Mr.zakas'</span>&#125;;</div><div class="line">        <span class="keyword">return</span> Books; <span class="comment">//返回公共接口API</span></div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>通过调用全局函数define()，并给它传入模块名字、依赖列表、一个工厂方法，依赖列表加载完成后执行这个工厂方法。AMD模块模式中，每一个依赖都会对应到独立的参数传入到工厂方法里，即每个被命名的依赖最后都会创建一个对象被传入到工厂方法内。模块可以是匿名的(即可以省略第一个参数)，因为模块加载器可以根据JavaScript文件名来当做模块名字。要使用AMD模块，需要通过使用与AMD模块兼容的模块加载器，如RequireJS、Dojo来加载AMD模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">requre([<span class="string">'my-books'</span>] , <span class="function"><span class="keyword">function</span>(<span class="params">books</span>)</span>&#123;</div><div class="line">            books.author;</div><div class="line">            ...</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>以上所说的模块都是是基于函数的模块，它并不是一个能被稳定识别的模式（编译器无法识别），它们的API语义只是在运行时才会被考虑进来。因此可以在运行时修改一个模块的API</p>
<h2 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h2><p>ES6为模块增加了一级语法支持，每个模块都可以导入其它模块或模块的特定API成员，同样也可以导出自己的API成员；ES6的模块没有‘行内’格式，必须被定义在独立的文件中（一个文件一个模块）ES6的模块API更加稳定，由于编译器可以识别，在编译时就检查对导入的API成员的引用是否真实存在。若不存在，则编译器会在运行时就抛出‘早期’错误，而不会像往常一样在运行期采用动态的解决方案；</p>
<p>bar.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'let me introduce: '</span>+who;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> hello; <span class="comment">//导出API: hello</span></div></pre></td></tr></table></figure>
<p>foo.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导入bar模块的hello()</span></div><div class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'bar'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hungry = <span class="string">'hippo'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(hello(hungry).toUpperCase());</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> awesome;<span class="comment">//导出API: awesome</span></div></pre></td></tr></table></figure>
<p>baz.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//完整导入foo和bar模块</span></div><div class="line"><span class="built_in">module</span> foo <span class="keyword">from</span> <span class="string">'foo'</span>;</div><div class="line"><span class="built_in">module</span> bar <span class="keyword">from</span> <span class="string">'bar'</span>;</div><div class="line">foo.awesome();</div></pre></td></tr></table></figure></p>
<ol>
<li>import可以将一个模块中的一个或多个API导入到当前作用域中，并分别绑定在一个变量上；</li>
<li>module会将整个模块的API导入并绑定到一个变量上；</li>
<li>export会将当前模块的一个标识符（变量、函数）导出为公共API；</li>
<li>模块文件中的内容会被当做好像包含在作用域闭包中一样来处理，就和函数闭包模块一样；</li>
</ol>
</div></article><div class="tags"><a href="/tags/JS/">JS</a><a href="/tags/模块化/">模块化</a></div><div class="paginator"><a href="/2016/09/20/2016-09-20/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2016/09/30/2016-09-30/';
    this.page.identifier = '2016/09/30/2016-09-30/';
    this.page.title = '模块化JS代码';
};
(function() {
var d = document, s = d.createElement('script');

s.src = '//Your disqus ID.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a></p><p class="since">&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Jaywii</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>